// Copyright (c) 2014 Tom Steele, Dan Kottmann, FishNet Security
// See the file license.txt for copying permission

Template.vulnerabilityList.projectId = function() {
  return Session.get('projectId');
};

Template.vulnerabilityList.moreToShow = function() {
  if (Template.vulnerabilityList.total() > Session.get('vulnerabilityViewLimit')) {
    return true;
  } else {
    return false;
  }
};

Template.vulnerabilityList.start = function() {
  var n = Session.get('vulnerabilityViewSkip') + 1;
  if (n > Template.vulnerabilityList.total()) {
    n = Template.vulnerabilityList.total();
  }
  return n;
};

Template.vulnerabilityList.end = function() {
  var n = Session.get('vulnerabilityViewSkip') + Session.get('vulnerabilityViewLimit');
  if (n > Template.vulnerabilityList.total())
    n = Template.vulnerabilityList.total();
  return n;
};

Template.vulnerabilityList.total = function() {
  return Counts.findOne(Session.get('projectId')).vulnCount;
};

Template.vulnerabilityList.flagFilter = function() {
  return Session.get('vulnerabilityListFlagFilter');
};

Template.vulnerabilityList.vulnerabilities = function() {
  var limit = Session.get('vulnerabilityViewLimit') || 25;
  var query = {"project_id": Session.get('projectId'), "status": {"$in": []}};
  if (Session.get('vulnerabilityListFlagFilter', 'enabled')) {
    query.flag = true;
  }
  if (!Session.equals('vulnerabilityListStatusButtongrey', 'disabled')) {
    query.status.$in.push('lair-grey');
  }
  if (!Session.equals('vulnerabilityListStatusButtonblue', 'disabled')) {
    query.status.$in.push('lair-blue');
  }
  if (!Session.equals('vulnerabilityListStatusButtongreen', 'disabled')) {
    query.status.$in.push('lair-green');
  }
  if (!Session.equals('vulnerabilityListStatusButtonorange', 'disabled')) {
    query.status.$in.push('lair-orange');
  }
  if (!Session.equals('vulnerabilityListStatusButtonred', 'disabled')) {
    query.status.$in.push('lair-red');
  }
  var search = Session.get('vulnerabilitySearch');
  if (search) {
    query.$or = [
      {"cvss": {"$regex": search, "$options": "i"}},
      {"title": {"$regex": search, "$options": "i"}},
      {"last_modified_by": {$regex: search, "$options": "i"}},
      {"tags": search},
    ];
  }
  Session.set('vulnerabilityQuery', query);
  var vulns = Vulnerabilities.find(query, {sort: {"cvss": -1, "title": 1}, limit: limit}).fetch();
  if (!vulns) {
    return false
  }
  vulns.forEach(addVulnRating);
  vulns.forEach(function(v) {v.count = v.hosts.length;});
  return vulns;
};

Template.vulnerabilityList.searchTerm = function() {
  return Session.get('vulnerabilitySearch');
};

Template.vulnerabilityList.vulnerabilityListStatusButtonActive = function(status) {
  if (Session.equals('vulnerabilityListStatusButton' + status, 'disabled')) {
    return 'disabled';
  }
  return false;
};

Template.vulnerabilityList.events({
  'click #flag-filter-enable': function() {
    return Session.set('vulnerabilityListFlagFilter', 'enabled');
  },

  'click #flag-filter-disable': function() {
    return Session.set('vulnerabilityListFlagFilter', null);
  },

  'click .flag-enabled': function() {
    return Meteor.call('disableVulnerabilityFlag', Session.get('projectId'), this._id);
  },

  'click .flag-disabled': function() {
    return Meteor.call('enableVulnerabilityFlag', Session.get('projectId'), this._id);
  },

  'click .confirmed-enabled': function() {
    return Meteor.call('disableVulnerabilityConfirmed', Session.get('projectId'), this._id);
  },

  'click .confirmed-disabled': function() {
    return Meteor.call('enableVulnerabilityConfirmed', Session.get('projectId'), this._id);
  },

  'click .vulnerability-status-button': function(event) {
    var id = 'vulnerabilityListStatusButton' + event.target.id;
    if (Session.equals(id, null) || typeof Session.get(id) === 'undefined') {
      return Session.set(id, 'disabled');
    }
    return Session.set(id, null);
  },

  'keyup #vulnerability-list-search': function(event, tpl)  {
    Session.set('vulnerabilitySearch', tpl.find('#vulnerability-list-search').value);
  },

  'click .vulnerability-status': function() {
    var newStatus = STATUS_MAP[STATUS_MAP.indexOf(this.status) + 1];
    if (STATUS_MAP.indexOf(this.status) + 1 > 4) {
      newStatus = STATUS_MAP[0];
    }
    Meteor.call('setVulnerabilityStatus', Session.get('projectId'), this._id, newStatus);
  },

  'click #remove-vulnerabilities': function() {
    var projectId = Session.get('projectId');
    var vulnerabilityIds = [];
    var inputs = $('.vulnerability-checked');
    inputs.each(function(){
      if ($(this).is(':checked')) {
        vulnerabilityIds.push($(this).attr('id'));
      }
    });
    vulnerabilityIds.forEach(function(id) {
      Meteor.call('removeVulnerability', projectId, id);
    });
  },

  'click #next-page': function() {
    var id = Session.get('projectId');
    var previousSkip = Session.get('vulnerabilityViewSkip') || 0;
    var newSkip = previousSkip + 25;
    var count = Counts.findOne(Session.get('projectId')).vulnCount;
    if (newSkip >= count)
      newSkip = previousSkip;
    Session.set('vulnerabilityViewSkip', newSkip);
    return Router.go('/project/' + id + '/vulnerabilities');
  },

  'click #prev-page': function() {
    var id = Session.get('projectId');
    var previousSkip = Session.get('vulnerabilityViewSkip') || 0;
    var newSkip = previousSkip - 25;
    if (newSkip < 0)
      newSkip = 0;
    Session.set('vulnerabilityViewSkip', newSkip);
    return Router.go('/project/' + id + '/vulnerabilities');
  },

  'click #load-more': function() {
    var previousLimit = Session.get('vulnerabilityViewLimit') || 25;
    var newLimit = previousLimit + 25;
    Session.set('vulnerabilityViewLimit', newLimit);
  },

  'click #load-all': function() {
    Session.set('vulnerabilityViewLimit', 10000);
  }
});
