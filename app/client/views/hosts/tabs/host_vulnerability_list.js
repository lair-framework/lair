// Copyright (c) 2014 Tom Steele, Dan Kottmann, FishNet Security
// See the file license.txt for copying permission

Template.hostVulnerabilityList.projectId = function() {
  return Session.get('projectId');
};

Template.hostVulnerabilityList.flagFilter = function() {
  return Session.get('vulnerabilityListFlagFilter');
};

Template.hostVulnerabilityList.vulnerabilities = function() {
  var projectId = Session.get('projectId');
  var hostId = Session.get('hostId');
  var host = Hosts.findOne(hostId);
  if (!host) {
    return false;
  }
  var query = {"project_id": projectId, "hosts.string_addr": host.string_addr, "status": {"$in": []}};
  if (Session.equals('vulnerabilityListFlagFilter', 'enabled')) {
    query.flag = true;
  }
  if (!Session.equals('vulnerabilityListStatusButtongrey', 'disabled')) {
    query.status.$in.push('lair-grey');
  }
  if (!Session.equals('vulnerabilityListStatusButtonblue', 'disabled')) {
    query.status.$in.push('lair-blue');
  }
  if (!Session.equals('vulnerabilityListStatusButtongreen', 'disabled')) {
    query.status.$in.push('lair-green');
  }
  if (!Session.equals('vulnerabilityListStatusButtonorange', 'disabled')) {
    query.status.$in.push('lair-orange');
  }
  if (!Session.equals('vulnerabilityListStatusButtonred', 'disabled')) {
    query.status.$in.push('lair-red');
  }
  var search = Session.get('vulnerabilitySearch');
  if (search) {
    query.$or = [
      {"cvss": {"$regex": search, "$options": "i"}},
      {"title": {"$regex": search, "$options": "i"}},
      {"last_modified_by": {$regex: search, "$options": "i"}}
    ];
  }

  // search through a returned list of vulnerabilities, returning a list of
  // only those that match the selected host. additionally, add the port and protocol.
  // remove_string is a probably not so clever hack to handle deletion of vulnerabilities,
  // it creates a string of id-string_addr-port-protocol which is later split up into an array
  var vulnerabilityWithPortList = [];
  Vulnerabilities.find(query, {sort: {"cvss": -1, "title": 1}}).fetch().forEach(function(vulnerability) {
    vulnerability.hosts.forEach(function(h){
       if (h.string_addr === host.string_addr) {
         var portId = Ports.findOne({"project_id": projectId, "host_id": hostId, "port": h.port, "protocol": h.protocol})._id;
         vulnerabilityWithPortList.push({"_id": vulnerability._id, "title": vulnerability.title, "cvss": vulnerability.cvss,
                                         "status": vulnerability.status, "port": h.port, "protocol": h.protocol, "portId": portId,
                                         "remove_string": [vulnerability._id, h.string_addr, h.port, h.protocol].join('-')});
       }
    });
  });
  vulnerabilityWithPortList.forEach(addVulnRating);
  return vulnerabilityWithPortList;
};

Template.hostVulnerabilityList.searchTerm = function() {
  return Session.get('vulnerabilitySearch');
};

Template.hostVulnerabilityList.vulnerabilityListStatusButtonActive = function(status) {
  if (Session.equals('vulnerabilityListStatusButton' + status, 'disabled')) {
    return 'disabled';
  }
  return false;
};

Template.hostVulnerabilityList.events({
  'click #flag-filter-enable': function() {
    return Session.set('vulnerabilityListFlagFilter', 'enabled');
  },

  'click #flag-filter-disable': function() {
    return Session.set('vulnerabilityListFlagFilter', null);
  },

  'click .vulnerability-status-button': function(event) {
    var id = 'vulnerabilityListStatusButton' + event.target.id;
    if (Session.equals(id, null)) {
      return Session.set(id, 'disabled');
    }
    return Session.set(id, null);
  },

  'keyup #vulnerability-list-search': function(event, tpl)  {
    Session.set('vulnerabilitySearch', escapeRegex(tpl.find('#vulnerability-list-search').value));
  },

  'click #remove-vulnerabilities': function() {
    var projectId = Session.get('projectId');
    var vulnerabilityIds = [];
    var inputs = $('.vulnerability-checked');
    inputs.each(function(){
      if ($(this).is(':checked')) {
        vulnerabilityIds.push($(this).attr('id'));
      }
    });
    vulnerabilityIds.forEach(function(id) {
      var data = id.split('-');
      Meteor.call('removeHostFromVulnerability', projectId, data[0], data[1], parseInt(data[2]), data[3]);
    });
  }
});
